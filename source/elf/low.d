//          Copyright Yazan Dabain 2014.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

module elf.low;

import elf.low32, elf.low64;
import elf.meta;

import std.conv : to;

alias ELF_Half = ELF64_Half;
alias ELF_Word = ELF64_Word;
alias ELF_SWord = ELF64_SWord;
alias ELF_XWord = ELF64_XWord;
alias ELF_Addr = ELF64_Addr;
alias ELF_Off = ELF64_Off;
alias ELF_Section = ELF64_Section;

align(1) struct ELFIdent {
align(1):
	char mag0;
	char mag1;
	char mag2;
	char mag3;
	ubyte class_;
	ubyte data;
	ubyte version_;
	ubyte osabi;
	ubyte abiversion;
	ubyte[6] pad;
	ubyte nident;
}

static assert(ELFIdent.sizeof == 16);

struct Identifier {
	ELFIdent data;

	FileClass fileClass() {
		return cast(FileClass) data.class_;
	}

	DataEncoding dataEncoding() {
		return cast(DataEncoding) data.data;
	}

	OSABI osABI() {
		return cast(OSABI) data.osabi;
	}

	ubyte abiVersion() {
		return data.abiversion;
	}
}

enum FileClass : ubyte {
	class32 = 1, class64 = 2,
}

enum DataEncoding : ubyte {
	littleEndian = 1, bigEndian = 2,
}

enum OSABI : ubyte {
	sysv = 0x00,
	hpux = 0x01,
	netBSD = 0x02,
	linux = 0x03,
	solaris = 0x06,
	aix = 0x07,
	irix = 0x08,
	freeBSD = 0x09,
	openBSD = 0x0C,
	standalone = 0xFF,
}

enum ObjectFileType : ELF_Half {
	none = 0x0000,
	relocatable = 0x0001,
	executable = 0x0002,
	shared_ = 0x0003,
	core = 0x0004,
	lowOS = 0xFE00,
	highOS = 0xFEFF,
	lowProccessor = 0xFF00,
	highProcessor = 0xFFFF,
}

enum SectionType : ELF_Word {
	null_ = 0x0000_0000,
	programBits = 0x0000_0001,
	symbolTable = 0x0000_0002,
	stringTable = 0x0000_0003,
	relocation = 0x0000_0004,
	symbolHashTable = 0x0000_0005,
	dynamicLinkingTable = 0x0000_0006,
	note = 0x0000_0007,
	noBits = 0x0000_0008,
	rel = 0x0000_0009,
	shlib = 0x0000_000A,
	dynamicLoaderSymbolTable = 0x0000_000B,
	lowOS = 0x6000_0000,
	highOS = 0x6FFF_FFFF,
	lowProcessor = 0x7000_0000,
	highProcessor = 0x7FFF_FFFF,
}

// TODO: Review this
enum SectionFlag : ELF64_XWord {
	write = 0x0000_0001,
	alloc = 0x0000_0002,
	executable = 0x0000_0004,
	maskOS = 0x0F00_0000,
	maskProcessor = 0xF000_0000,
}

enum TargetISA : ELF_Word {
	sparc = 0x02,
	x86 = 0x03,
	mips = 0x08,
	powerpc = 0x14,
	arm = 0x28,
	superh = 0x2A,
	ia64 = 0x32,
	x86_64 = 0x3E,
	aarch64 = 0xB7,
}

/**
 * Non-exhaustive list of legal values for d_tag (.dynamic section tag for entries)
 *
 * See /usr/include/elf.h for details.
 */
enum DynTag : uint {
	NULL = 0,
	NEEDED = 1,
	SONAME = 14,
	SYMBOLIC = 16 // listed for reference, no support implemented
}

/**
 * An ELF .note.gnu.build-id section contains a hash used for identifying built objects
 *
 * "GNU":
 *  decimal = [  71,   78,   85]
 *  hex     = [0x47, 0x4E, 0x55]
 *
 * $ objdump -w --section=".note.gnu.build-id" -s /lib64/libtinfo.so.6
 *
 * /lib64/libtinfo.so.6:     file format elf64-x86-64
 *
 * Contents of section .note.gnu.build-id:
 *  addr n_namesz n_descsz n_type   |G N U
 *  02c8 04000000 14000000 03000000 474e5500  ............GNU.
 *       |0x14 = 20 = 5*4 bytes represented
 *       |as hex numbers->string in a
 *       |160 bit SHA1 hash (20*8 = 160)
 *  02d8 4749ec9c b6200033 9650eab4 24702048  GI... .3.P..$p H
 *  02e8 9b89313a                             ..1:
 *
 * In the above, n_type corresponds to:
 *
 * #define NT_GNU_BUILD_ID 3
 *
 * ... which corresponds to:
 *
 * Build ID bits as generated by ld --build-id.
 * The descriptor consists of any nonzero number of bytes.
 *
 * Data sizes are always 32bit words in the note headers:
 *
 * typedef uint32_t Elf64_Word;
 * typedef uint32_t Elf32_Word;
 *
 * Note section contents. Each entry in the note section begins with
 * a header of a fixed form:
 *
 * typedef struct
 * {
 *   Elf32_Word n_namesz;                  // Length of the note's name.
 *   Elf32_Word n_descsz;                  // Length of the note's descriptor.
 *   Elf32_Word n_type;                    // Type of the note.
 * } Elf32_Nhdr;
 *
 * typedef struct
 * {
 *   Elf64_Word n_namesz;                  // Length of the note's name.
 *   Elf64_Word n_descsz;                  // Length of the note's descriptor.
 *   Elf64_Word n_type;                    // Type of the note.
 * } Elf64_Nhdr;
 *
 */

align(1) struct ELFNoteHeaderL {
	uint noteNameSize;  // typically 4
	uint noteDescriptorSize; // 128 - 160 bits = 16 - 20 bytes = 0x10 - 0x14 in hex.
	uint noteType; // 3 is NT_GNU_BUILD_ID
	/*
		The rest of the section after the 3x4 bytes header is content.
		First, we read noteNameSize bytes in order to get the name of the note (= "GNU" when using Linux).
		Then, we read noteDescriptorSize bytes and ensure that we don't read beyond the end of the section
	 */
 }
